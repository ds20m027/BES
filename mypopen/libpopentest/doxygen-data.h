/* This file is generated - do not edit! */
#define MEMBERDEF_mypopentest00 "Try to call mypclose() prior to mypopen() - This should yield an error and errno should be set to ECHILD"
#define MEMBERDEF_mypopentest01 "Try to call mypopen() twice (without an intermediate mypclose()) - This should yield an error and errno should be set to EAGAIN. Additionally verify that mypopen() does not return for the created child process, but properly terminates the child process."
#define MEMBERDEF_mypopentest02 "Try to call mypclose() with a bogus file pointer (i.e., one that has not been obtained via mypopen(). - This should yield an error and errno should be set to EINVAL. Additionally verify that mypopen() does not return for the created child process, but properly terminates the child process."
#define MEMBERDEF_mypopentest03 "Try to call mypclose() with NULL as file pointer. - This should yield an error and errno should be set to EINVAL. Additionally verify that mypopen() does not return for the created child process, but properly terminates the child process."
#define MEMBERDEF_mypopentest04 "Try to call mypopen() with a type parameter of NULL - This should yield an error and errno should be set to EINVAL. Additionally verify that mypopen() does not return for the created child process, but properly terminates the child process."
#define MEMBERDEF_mypopentest05 "Try to call mypopen() with a type parameter of \"x\" - This should yield an error and errno should be set to EINVAL. Additionally verify that mypopen() does not return for the created child process, but properly terminates the child process."
#define MEMBERDEF_mypopentest06 "Try to call mypopen() with a type parameters \"rotz\" and \"what the ...\" (i.e., something that start with 'r' and 'w' but is actually a string different from \"r\" and \"w\". - This should yield and error and errno should be set to EINVAL. Additionally verify that mypopen() does not return for the created child process, but properly terminates the child process."
#define MEMBERDEF_mypopentest07 "Call mypopen() with a command that requires input. Check if the created child process is really there. Additionally verify that mypopen() does not return for the created child process, but properly terminates the child process. Call mypclose() and check if the exit status of the child process has been properly consumed via wait() or waitpid()."
#define MEMBERDEF_mypopentest08 "Call mypopen(), fork(), mypclose() - forked child process must still be there. Additionally verify that mypopen() does not return for the created child process, but properly terminates the child process."
#define MEMBERDEF_mypopentest09 "Call mypopen(\"echo 'This is a test.'; sleep 1; echo 'Second line\n for test.'\", \"r\"); read from file pointer; check if we read the two lines; call mypclose() Additionally verify that mypopen() does not return for the created child process, but properly terminates the child process."
#define MEMBERDEF_mypopentest10 "Call mypopen(\"cat > some_temp_file\", \"w\"); write to file pointer; check if some_temp_file contains the respective text. Additionally verify that mypopen() does not return for the created child process, but properly terminates the child process."
#define MEMBERDEF_mypopentest11 "Set via setrlimit(2) the resource limit for open files (RLIMIT_NOFILE) to 1; call mypopen() and check whether it fails (i.e, return NULL with errno set to EMFILE) due to the failing pipe() call. Additionally verify that mypopen() does not return for the created child process, but properly terminates the child process."
#define MEMBERDEF_mypopentest12 "Set via setrlimit(2) the resource limit for processes (RLIMIT_NPROC); call mypopen() and check whether it fails with errno set to EAGAIN (due to the failing fork() call). Additionally verify that mypopen() does not return for the created child process, but properly terminates the child process. Furthermore verify that the pipe is properly closed in case fork() fails. Last but not least call mypclose() and check that it fails as well in order to test is the stored static PID for the child is properly initialized to -1 (the value returned by a failed fork) and/or properly reset to -1 upon a failed fork()."
#define MEMBERDEF_mypopentest13 "Check whether the exit status of the child process is extracted properly with wait() or waitpid(). Additionally verify that mypopen() does not return for the created child process, but properly terminates the child process."
#define MEMBERDEF_mypopentest14 "Check for correct setting of errno to ECHILD in case the exit status cannot be extracted (i.e., if WIFEXITED() returns FALSE). Additionally verify that mypopen() does not return for the created child process, but properly terminates the child process."
#define MEMBERDEF_mypopentest15 "Checks if the stored static PID for the child and the stored static file pointer are properly properly reset in mypclose() and thus we can do a sequence of mypopen(), mypclose(), mypopen(), mypclose() correctly. Additionally verify that mypopen() does not return for the created child process, but properly terminates the child process."
#define MEMBERDEF_mypopentest16 "Checks if the stored static PID for the child and the stored static file pointer are properly properly reset in mypclose() and thus when doing a sequence of mypopen(), mypclose() and mypclose(), the second mypclose() fails and sets errno to ECHILD. Additionally verify that mypopen() does not return for the created child process, but properly terminates the child process."
#define MEMBERDEF_mypopentest17 "Checks if the stored static PID for the child and the stored static file pointer are properly properly reset (or remain set) to invalid values if mypopen() fails somewhere in between (e.g., upon fdopen()). => Let fdopen() fail by installing a malloc_hook(3) that returns NULL and check if mypopen() can be called again ...). Additionally verify that mypopen() does not return for the created child process, but properly terminates the child process."
#define MEMBERDEF_mypopentest18 "Call mypopen() with mode set to reading. Verify that stdin, stdout, stderr, and the read end of the pipe are the only open file descriptors after the mypopen() call. Call mypclose(). Verify that stdin, stdout, and stderr are the only open file descriptors after the mypclose() call (i.e., verify that the read end of the pipe has been properly closed). Additionally verify that mypopen() does not return for the created child process, but properly terminates the child process."
#define MEMBERDEF_mypopentest19 "Call mypopen() with mode set to reading. Verify that stdin, stdout, stderr, are the only open file descriptors in the exec()'ed child process. Call mypclose() and check that it succeeds. Additionally verify that mypopen() does not return for the created child process, but properly terminates the child process."
#define MEMBERDEF_mypopentest20 "Try to call mypclose() with a bogus file pointer (i.e., one that has not been obtained via mypopen() but where the underlying file descriptor is identical to the one of a file pointer obtained by mypopen(). - This should yield an error and errno should be set to EINVAL. Additionally verify that mypopen() does not return for the created child process, but properly terminates the child process."
#define MEMBERDEF_mypopentest21 "Call mypopen() with mode set to writing. Verify that stdin, stdout, stderr, and the read end of the pipe are the only open file descriptors after the mypopen() call. Call mypclose(). Verify that stdin, stdout, and stderr are the only open file descriptors after the mypclose() call (i.e., verify that the read end of the pipe has been properly closed). Additionally verify that mypopen() does not return for the created child process, but properly terminates the child process."
#define MEMBERDEF_mypopentest22 "Check whether mypclose() behaves properly (i.e., returns -1 and sets errno to ECHLD) if waitpid() fails for reasons different from EINTR. Additionally verify that mypopen() does not return for the created child process, but properly terminates the child process."
#define MEMBERDEF_mypopentest23 "Do a mypopen() with a really long commandline that causes execl() to fail and set errno to E2BIG. - Check whether mypopen() is successful anyway (i.e., returns something != NULL) and check wehther the child process correctly terminates with EXIT_FAILURE. Additionally verify that mypopen() does not return for the created child process, but properly terminates the child process."
#define MEMBERDEF_mypopentest24 "Checks if mypopen() properly handles the case where stdin already is the read pipe end => closes stdin prior to calling mypopen(). Additionally verify that mypopen() does not return for the created child process, but properly terminates the child process."
#define MEMBERDEF_mypopentest25 "Checks if mypopen() properly handles the case where stdout already is the read pipe end => closes stdout prior to calling mypopen(). Additionally verify that mypopen() does not return for the created child process, but properly terminates the child process."
#define MEMBERDEF_mypopentest26 "Do a mypopen() but let dup2() fail. - Check whether mypopen() is successful anyway (i.e., returns something != NULL) and check whether the child process correctly terminates with EXIT_FAILURE. Additionally verify that mypopen() does not return for the created child process, but properly terminates the child process."
#define MEMBERDEF_mypopentest27 "Do a mypopen() but let dup2() fail. - Check whether mypopen() is successful anyway (i.e., returns something != NULL) and check whether the child process correctly terminates with EXIT_FAILURE. Additionally ensure that no atexit() handlers are called in the child process because of the child process calling exit() instead of _Exit() or _exit(). Additionally verify that mypopen() does not return for the created child process, but properly terminates the child process."
#define MEMBERDEF_mypopentest28 "Do a mypopen() with a really long commandline that causes execl() to fail and set errno to E2BIG. - Check whether mypopen() is successful anyway (i.e., returns something != NULL) and check whether the child process correctly terminates with EXIT_FAILURE. Additionally ensure that no atexit() handlers are called in the child process because of the child process calling exit() instead of _Exit() or _exit(). Additionally verify that mypopen() does not return for the created child process, but properly terminates the child process."
#define MEMBERDEF_mypopentest29 "Set errno to various values different from 0 to 1024 and do a mypopen() - Check whether mypopen() is successful (should be). Do a mypclose() and check whether that is successful (should be)."
#define MEMBERDEF_mypopentest30 "Do a mypopen()/mypclose() session and simulate that the waitpid() call is interrupted by a signal (returns -1 and sets errno to EINTR) a few times. This should not cause mypclose() to fail."
