/**
 * @file popentest.c
 * Automated test suite for Betriebsysteme mypopen()/mypclose() module
 * Beispiel 2
 *
 * @author Thomas M. Galla <galla@technikum-wien.at>
 * @author Bernd Petrovitsch <petrovitsch@technikum-wien.at>
 * @date 2015/04/30
 *
 * @version $Revision: 965 $
 *
 * @todo Remove now useless clean-up stuff in child processes
 *
 * URL: $HeadURL: https://svn.petrovitsch.priv.at/ICSS-BES/trunk/2014/src/mypopen/popentest.c $
 *
 * Last Modified: $Author: bernd $
 */

/**
 * \mainpage Automated test suite for the Betriebssysteme mypopen()/mypclose module
 *
 * This library called \c libpopentest.a provides an automated test
 * suite for the \c mypopen()/mypclose() module. The library
 * implements 31 tests named \a mypopentest00() (Test 00) to \a
 * mypopentest30() (Test 30) and provides a \a main() function that
 * calls these tests in sequence.
 *
 * In case only some of the tests shall be executed a list of tests
 * to be executed can be provided as commandline arguments to the
 * \c popentest executable, e.g., the following commandline triggers
 * the execution of tests 1, 3, 5, and 7:
 *
\verbatim
./popentest 1 3 5 7
\endverbatim
 *
 * The library assumes that your versions of \c popen()/\c pclose() are
 * called \c mypopen() and \c mypclose() respectively.
 *
 * The results of the tests are written to \c stdout. - Any errors during
 * execution are printed to \c stderr. - See below for an example output:
 *
 \verbatim
 ./popentest: Test "mypopentest00" passed
 ./popentest: Test "mypopentest01" passed
 ./popentest: Test "mypopentest02" passed
 ./popentest: Test "mypopentest03" passed
 ./popentest: Test "mypopentest04" passed
 ./popentest: Test "mypopentest05" passed
 ./popentest: Test "mypopentest06" passed
 ./popentest: Test "mypopentest07" passed
 ./popentest: Test "mypopentest08" passed
 ./popentest: Test "mypopentest09" passed
 ./popentest: Test "mypopentest10" passed
 ./popentest: Test "mypopentest11" passed
 ./popentest: Test "mypopentest12" passed
 ./popentest: Test "mypopentest13" passed
 ./popentest: Test "mypopentest14" passed
 ./popentest: Test "mypopentest15" passed
 ./popentest: Test "mypopentest16" passed
 ./popentest: Test "mypopentest17" passed
 ./popentest: Test "mypopentest18" passed
 ./popentest: Test "mypopentest19" passed
 ./popentest: Test "mypopentest20" passed
 ./popentest: Test "mypopentest21" passed
 ./popentest: Test "mypopentest22" passed
 ./popentest: Test "mypopentest23" passed
 ./popentest: Test "mypopentest24" passed
 ./popentest: Test "mypopentest25" passed
 ./popentest: Test "mypopentest26" passed
 ./popentest: Test "mypopentest27" passed
 ./popentest: Test "mypopentest28" passed
 ./popentest: Test "mypopentest29" passed
 ./popentest: Test "mypopentest30" passed
 \endverbatim
 *
 * To link your \c mypopen()/mypclose() module (name \c mypopen.o is
 * assumed in the command line below) with the library, you have to issue
 * the following command in for the final linking step:
 *
 \verbatim
 gcc52 -o popentest mypopen.o -lpopentest -ldl
 \endverbatim
*/

/*
 * -------------------------------------------------------------- includes --
 */

#include "mypopen.h"
#include "utils.h"

#include "doxygen-data.h"

#include <assert.h>
#include <errno.h>
#include <error.h>
#include <getopt.h>
#include <limits.h>
#include <malloc.h>
#include <stdarg.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <signal.h>
#include <unistd.h>
#include <wait.h>

#include <sys/types.h>
#include <sys/time.h>
#include <sys/resource.h>
#include <sys/wait.h>

#include <dlfcn.h>

/*
 * --------------------------------------------------------------- defines --
 */

static const char *emph_success = "\033[1;32m";
static const char *emph_failed  = "\033[1;31m";
static const char *emph_off     = "\033[0m";

#define PROCESS_PATTERN "look_for_me_if_you_wanna_find_me"
#define POPENCOMMAND "cat; echo " PROCESS_PATTERN "_%d > /dev/null"
#define POPENCOMMAND2 "cat > %s"
#define FINDPROCESSCOMMAND "ps x | grep '%s' | grep -vq grep"
#define PIDPATTERN "0123456789"
#define LINE1 "This is a test."
#define LINE2 "Second line for test."

#define MAXLINE 256
#define MAXPIPES 2
#define MAXCHILDREN 1
#define MAX_COMMAND_LENGTH 128 

#define EXPECTED_EXIT_STATUS 42
#define OTHER_EXIT_STATUS 13
#define EXPECTED_EXIT_STATUS_STRING STRINGIFY(EXPECTED_EXIT_STATUS)

#define REALLY_LONG_COMMAND_LENGTH 131073UL

#define FAIL_AND_EXIT(type)                 		\
    do {						\
        printfail(__LINE__, type);   \
        freeresources();				\
	EXIT();						\
        exit(EXIT_FAILURE);				\
    } while (0)						\

#define FAIL(type)					\
    do {						\
        printfail(__LINE__, type);   \
        freeresources();				\
	EXIT();						\
        return;						\
    } while (0)						\

#define PASS()                                  \
    do {                                        \
        printpass();	                    \
	EXIT();						\
        return;                                 \
    } while (0)

#define STRINGIFY(x)  STRINGIFY_HLP(x)
#define STRINGIFY_HLP(x) #x

/* defined own empty version for annuminas if not #defined */
#ifndef __MALLOC_HOOK_VOLATILE
#define __MALLOC_HOOK_VOLATILE
#endif

/*
 * -------------------------------------------------------------- typedefs --
 */

typedef enum
{
    MANDATORY,
    OPTIONAL
} testtype;

typedef void (*testfunc_type)(void);

struct test {
    const testfunc_type testfunc;
    const char * const testfunc_name;
    const char * const testfunc_desc;
};

/*
 * ------------------------------------------------------------ prototypes --
 */

static void my_malloc_init_hook(void);
static void *my_malloc_hook(size_t, const void *);

/*
 * --------------------------------------------------------------- globals --
 */

// we need that in signal handlers too
const char *testname = "<not yet set>";
const char *testdescription = "<not yet set>";

static FILE *bogusreadfp = NULL;
static FILE *boguswritefp = NULL;
static FILE *somefp = NULL;
static FILE *fp[MAXPIPES] = {0};
static pid_t dummychildpid = -1;

static int stdoutflushed = 0;
static volatile int alarmoccurred = 0;
static volatile FILE **fptoclose = NULL;

static volatile int let_malloc_fail = 0;
static volatile int let_dup2_fail = 0;
static volatile int number_of_interrupted_waitpids = 0;
static volatile int poisoned_errno = 0;

static int print_description = 0;

static void *(*old_malloc_hook)(size_t, const void *); /* to save original malloc hook */
void (*__MALLOC_HOOK_VOLATILE __malloc_initialize_hook) (void) = my_malloc_init_hook; /* override malloc init hook */

static int (*libc_dup2)(int oldfd, int newfd) = NULL;
static int (*libc_waitpid)(pid_t pid, int *status, int options) = NULL;

/*
 * ------------------------------------------------------------- functions --
 */

static void poison_errno_if_desired(void)
{
    if (poisoned_errno != 0)
    {
	TRACE("Poisoning errno to %d ...\n", poisoned_errno);
	errno = poisoned_errno;
    }
}

int dup2(int oldfd, int newfd)
{
    ENTER();

    if (let_dup2_fail)
    {
	TRACE("Letting dup2() fail by returning with -1 and setting errno to EBUSY ...\n");

	errno = EBUSY;
	
	EXIT();

	return -1;
    }

    poison_errno_if_desired();
    
    TRACE("Delegating to libc's version of dup2() ...\n");

    EXIT();

    /* now forward to libc dup2() */
    return libc_dup2(oldfd, newfd);
}

int waitpid(pid_t pid, int *status, int options)
{
    ENTER();

    if (number_of_interrupted_waitpids > 0)
    {
	--number_of_interrupted_waitpids;
	TRACE("Letting waitpid() fail by returning with -1 and setting errno to EINTR (will do so for the next %d times ...\n", number_of_interrupted_waitpids);

	errno = EINTR;
	
	EXIT();

	return -1;
    }

    poison_errno_if_desired();
    
    TRACE("Delegating to libc's version of waitpid() ...\n");

    EXIT();

    /* now forward to libc waitpid() */
    return libc_waitpid(pid, status, options);
}

static void my_malloc_init_hook(
    void
    )
{
    ENTER();

    TRACE(
	"Installing my_malloc_hook() as __malloc_hook and saving old value %p ...\n",
	__malloc_hook
	);

    old_malloc_hook = __malloc_hook;
    __malloc_hook = my_malloc_hook;

    EXIT();
}

static void *my_malloc_hook(
    const size_t size,
    const void * const caller
    )
{
    void *result;

    ENTER();

    (void)caller;

    if (let_malloc_fail)
    {
	TRACE("Letting malloc() fail by returning with NULL ...\n");

	EXIT();

	return NULL;
    }

    TRACE("Restoring old value %p as __malloc_hook ...\n", old_malloc_hook);

    /* restore old hook in order to prevent infinite recursion */
    __malloc_hook = old_malloc_hook;

    TRACE("Recursively calling malloc() ...\n");

    /* call malloc recursively */
    result = malloc(size);

    TRACE(
	"Saving (possibly changed) old value %p of __malloc_hook ...\n",
	__malloc_hook
	);

    /* save possibly changed value of hook */
    old_malloc_hook = __malloc_hook;

    TRACE("Installing my_malloc_hook() as __malloc_hook again ...\n");

    /* install our own hook gain */
    __malloc_hook = my_malloc_hook;

    EXIT();

    return result;
}

/**
 * \brief Print usage message
 *
 * This function prints a usage message to stderr and afterwards
 * terminates the program with status EXIT_FAILURE.
 *
 */
static void usage(void) __attribute__((noreturn));
static void usage(
    void
    )
{
    ENTER();

    (void) fprintf(
        stderr,
        "USAGE: %s [-v|--verbose] [-d|--description] [[-c|--color] [auto|never|always]] [<num1>] [<num2>] ...\n",
        program_invocation_name
        );

    EXIT();

    exit(EXIT_FAILURE);
}

static void say(FILE * const stream, const char * const fmt, ...) __attribute__((format(printf,2,3)));
static void say(
    FILE * const stream,
    const char * const fmt,
    ...
    )
{
    va_list ap;

    va_start(ap, fmt);

    if (vfprintf(stream, fmt, ap) < 0)
    {
        bailout("Cannot write to stdout");
    }

    va_end(ap);
}

static void printfail(
    int line,
    testtype type
    )
{
    ENTER();

    say(
	stderr,
        "%s:%s Test \"%s\" failed at line %d%s - This is %s\n",
        program_invocation_name,
	emph_failed,
        testname,
	line,
	emph_off,
        (type == OPTIONAL) ? "tolerated" : "not tolerated"
        );

    if (print_description != 0 && testdescription != NULL) {
        say(
	    stderr,
            "%s: %s\n",
            testname,
            testdescription
            );
    }

    EXIT();
}

static void printpass(void)
{
    ENTER();

    say(
	stderr,
        "%s:%s Test \"%s\" passed%s\n",
        program_invocation_name,
	emph_success,
        testname,
	emph_off
        );

    EXIT();
}

static void alarmhandler_terminate(
    const int sig
    )
{
    ENTER();

    /* prevent warning of unused variable */
    (void)sig;

    FAIL_AND_EXIT(MANDATORY);
}

static void initfiles(
    void
    )
{
    int i;

    ENTER();

    TRACE("Initializing array of file pointers (fp) with NULL ...\n");

    for (i = 0; i < MAXPIPES; ++i)
    {
        fp[i] = NULL;
    }

    TRACE("Initializing bogus file pointers bogusreadfp, boguswritefp, and somefp with NULL ...\n");

    bogusreadfp = NULL;
    boguswritefp = NULL;
    somefp = NULL;

    EXIT();
}

static void initpids(
    void
    )
{
    ENTER();

    TRACE("Initializing dummychildpid with -1 ...\n");

    dummychildpid = (pid_t) -1;

    EXIT();
}

static void initbogusfds(
    void
    )
{
    ENTER();

    TRACE("Creating bogus read file pointer (bogusreadfp) from /dev/zero ...\n");

    if ((bogusreadfp = fopen("/dev/zero", "r")) == NULL)
    {
        bailout("Cannot open /dev/zero for reading");
    }

    TRACE("Creating bogus write file pointer (boguswritefp) from /dev/null ...\n");

    if ((boguswritefp = fopen("/dev/null", "w")) == NULL)
    {
        bailout("Cannot open /dev/null for writing");
    }

    EXIT();
}

static void initresources(
    void
    )
{
    ENTER();

    initfiles();

    initpids();

    initbogusfds();

    EXIT();
}

static void freechild(
    pid_t * const pid
    )
{
    ENTER();

    if (*pid != (pid_t) -1)
    {
        TRACE("Killing process %ld with SIGTERM ...\n", (long int)*pid);

        /* try killing nicely */
        if (kill(*pid, SIGTERM) == -1)
        {
            TRACE("Killing process %ld with SIGKILL ...\n", (long int)*pid);

            /* die, sucker! */
            if (kill(*pid, SIGKILL) == -1)
            {
                *pid = (pid_t) -1;
                    
                bailout("Cannot kill child");
            }
        }

        TRACE("Waiting for process %ld ...\n", (long int)*pid);

        /* reap it */
        if (waitpid(*pid, NULL, WNOHANG) == (pid_t) -1)
        {
            bailout("Cannot reap child");
        }

        *pid = (pid_t) -1;
    }

    EXIT();
}

/**
 * \brief Free all allocated resources
 *
 * This function frees all allocated ressources and afterwards flushes stdout.
 *
 */
void freeresources(
    void
    )
{
    ENTER();

    TRACE("Trying to freechild(dummychildpid) ...\n");

    freechild(&dummychildpid);

    if (stdoutflushed)
    {
        TRACE("Flushing stdout ...\n");

        if (fflush(stdout))
        {
            stdoutflushed = 1;
            bailout("Cannot flush stdout");
        }

        stdoutflushed = 1;
    }

    EXIT();
}


static void blockonwrite(FILE * const lfp)
{
    static const char dummybuffer[1024 * 65]; /* 64 K Pipe Buffer */

    (void) fwrite(dummybuffer, 1, sizeof(dummybuffer), lfp);

    (void) fflush(lfp);
}

/**
 * \brief invoke mypopen() and assert that child does not return
 *
 * provides same signature as mypopen() which calls mypopen() and checks that we
 * do not return in the child process by comparing stored with actual PID
 */
static FILE *mycheckedpopen(
    const char * const cmd,
    const char * const mode
)
{
    const pid_t storedPID = getpid();
    FILE * const lfp = mypopen(cmd, mode);

    if (storedPID != getpid())
    {
	FAIL_AND_EXIT(MANDATORY);
    }

    return lfp;
}

/**
 * \brief Spawn a child process
 *
 * This function spawns a child process executing the function \a func
 * with the name \a funcname. - Afterwards the function waits for the proper
 * termination of the child process.
 *
 * \param test pointer to the test description
 *
 * \return nothing
 *
 */
static void spawn(const struct test * const test)
{
    testname = test->testfunc_name;
    testdescription = test->testfunc_desc;

    const pid_t childpid = fork();
    switch (childpid)
    {
    case -1:
        bailout("Cannot create child process for executing %s()", test->testfunc_name);
        break;
        
    case 0:
        TRACE("Child process %d is executing %s() ...\n", getpid(), test->testfunc_name);

        test->testfunc();

        exit(EXIT_SUCCESS);
        break;

    default:
        TRACE("Spawned child process %d executing %s() ...\n", childpid, test->testfunc_name);

        pid_t pid;
        int status = 0;
        while ((pid = waitpid(childpid, &status, 0)) != childpid)
        {
            if ((pid == -1) && (errno != EINTR))
            {
                bailout("Cannot wait child process %d executing %s()", childpid, test->testfunc_name);
            }
        }

        if (WIFEXITED(status))
        {
            TRACE(
                "Child process %d executing %s() terminated with status %d ...\n",
                childpid,
                test->testfunc_name,
                WEXITSTATUS(status)
                );
        }
        else if (WIFSIGNALED(status))
        {
            TRACE(
                "Child process %d executing %s() terminated with signal %d ...\n",
                childpid,
                test->testfunc_name,
                WTERMSIG(status)
                );
	    FAIL(MANDATORY);
        }
        else
        {
            TRACE("Child process %d executing %s() terminated abnormally ...\n", childpid, test->testfunc_name);
	    FAIL(MANDATORY);
        }
        break;
    }
}

/**
 * \brief Test 00
 *
 * Try to call mypclose() prior to mypopen() - This should yield an error
 * and errno should be set to ECHILD
 *
 * \return Nothing
 */
void mypopentest00(void)
{
    ENTER();

    initresources();

    /*
     * take caution here, since this might hang if passed a bogus file
     * pointer (i.e., one not obtained via popen())
     */
    (void) alarm(5);

    TRACE0("Trying mypclose(bogusreadfp) ...\n");

    errno = 0;

    if ((mypclose(bogusreadfp) != -1) || (errno != ECHILD))
    {
        bogusreadfp = NULL; /* mypclose has closed this one */
        alarmoccurred = 0;

        FAIL(MANDATORY);
    }

    if (alarmoccurred == 1)
    {
        bogusreadfp = NULL; /* mypclose has closed this one */
        alarmoccurred = 0;

        FAIL(MANDATORY);
    }

    /*
     * take caution here, since this might hang if passed a bogus file
     * pointer (i.e., one not obtained via popen())
     */
    (void) alarm(5);

    TRACE0("Trying mypclose(boguswritefp) ...\n");

    errno = 0;

    if ((mypclose(boguswritefp) != -1)  || (errno != ECHILD))
    {
        boguswritefp = NULL; /* mypclose has closed this one */
        alarmoccurred = 0;

        FAIL(MANDATORY);
    }

    if (alarmoccurred == 1)
    {
        boguswritefp = NULL; /* mypclose has closed this one */
        alarmoccurred = 0;

        FAIL(MANDATORY);

    }

    freeresources();

    PASS();
}

/**
 * \brief Test 01
 *
 * Try to call mypopen() twice (without an intermediate mypclose()) -
 * This should yield an error and errno should be set to EAGAIN.
 * Additionally verify that mypopen() does not return for the created child
 * process, but properly terminates the child process.
 *
 * \return Nothing
 */
void mypopentest01(void)
{
    ENTER();

    initresources();

    TRACE0("Trying mypopen(\"date 2> /dev/null\", \"r\") ...\n");

    if ((fp[0] = mycheckedpopen("date 2> /dev/null", "r")) == NULL)
    {
        FAIL(MANDATORY);
    }

    TRACE0("Trying mypopen(\"ls 2> /dev/null\", \"r\") ...\n");

    errno = 0;

    if (((fp[1] = mycheckedpopen("ls 2> /dev/null", "r")) != NULL) || (errno != EAGAIN))
    {
        FAIL(MANDATORY);
    }

    TRACE0("Trying mypclose(fp[0]) ...\n");

    /*
     *  call mypclose() in a checked way, since it might fail
     */
    if (mypclose(fp[0]) == -1)
    {
        fp[0] = NULL;
        FAIL(MANDATORY);
    }

    fp[0] = NULL;

    freeresources();

    PASS();
}

/**
 * \brief Test 02
 *
 * Try to call mypclose() with a bogus file pointer (i.e., one that
 * has not been obtained via mypopen(). - This should yield an error
 * and errno should be set to EINVAL.
 * Additionally verify that mypopen() does not return for the created child
 * process, but properly terminates the child process.
 *
 * \return Nothing
 */
void mypopentest02(void)
{
    ENTER();

    initresources();

    TRACE0("Trying mypopen(\"cat\", \"w\") ...\n");

    if ((fp[0] = mycheckedpopen("cat", "w")) == NULL)
    {
        FAIL(MANDATORY);
    }

    /*
     * take caution here, since this might hang if passed a bogus file
     * pointer (i.e., one not obtained via mypopen())
     */

    /*
     * store fp in global var, so that signal handler can close it upon
     * alarm
     */
    fptoclose = (volatile FILE **) &(fp[0]);

    (void) alarm(5);

    TRACE0("Trying mypclose(bogusreadfp) ...\n");

    errno = 0;

    if ((mypclose(bogusreadfp) != -1)  || (errno != EINVAL))
    {
        bogusreadfp = NULL; /* myclose has closed this one */
        alarmoccurred = 0;

        FAIL(MANDATORY);
    }

    /*
     * cancel alarm
     */
    (void) alarm(0);

    TRACE0("Checking whether mypclose() timed out ...\n");

    if (alarmoccurred == 1)
    {
        alarmoccurred = 0;

        FAIL(MANDATORY);
    }

    freeresources();

    PASS();
}

/**
 * \brief Test 03
 *
 * Try to call mypclose() with NULL as file pointer. - This should yield
 * an error and errno should be set to EINVAL.
 * Additionally verify that mypopen() does not return for the created child
 * process, but properly terminates the child process.
 *
 * \return Nothing
 */
void mypopentest03(void)
{
    ENTER();

    initresources();

    TRACE0("Trying mypopen(\"cat\", \"w\") ...\n");

    if ((fp[0] = mycheckedpopen("cat", "w")) == NULL)
    {
        FAIL(MANDATORY);
    }

    /*
     * take caution here, since this might hang if passed a bogus file
     * pointer (i.e., one not obtained via mypopen())
     */

    /*
     * store fp in global var, so that signal handler can close it upon
     * alarm
     */
    fptoclose = (volatile FILE **) &(fp[0]);

    (void) alarm(5);

    TRACE0("Trying mypclose(NULL) ...\n");

    errno = 0;

    if ((mypclose(NULL) != -1)  || (errno != EINVAL))
    {
        bogusreadfp = NULL; /* myclose has closed this one */
        alarmoccurred = 0;

        FAIL(OPTIONAL);
    }

    /*
     * cancel alarm
     */
    (void) alarm(0);

    TRACE0("Checking whether mypclose() timed out ...\n");

    if (alarmoccurred == 1)
    {
        alarmoccurred = 0;

        FAIL(MANDATORY);
    }

    freeresources();

    PASS();
}

/**
 * \brief Test 04
 *
 * Try to call mypopen() with a type parameter of NULL -  This should
 * yield an error and errno should be set to EINVAL.
 * Additionally verify that mypopen() does not return for the created child
 * process, but properly terminates the child process.
 *
 * \return Nothing
 */
void mypopentest04(void)
{
    ENTER();

    initresources();

    TRACE0("Trying mypopen(\"cat\", NULL) ...\n");

    errno = 0;

    if (((fp[0] = mycheckedpopen("cat", NULL)) != NULL) || (errno != EINVAL))
    {
        FAIL(MANDATORY);
    }

    freeresources();

    PASS();
}

/**
 * \brief Test 05
 *
 * Try to call mypopen() with a type parameter of "x" -  This should
 * yield an error and errno should be set to EINVAL.
 * Additionally verify that mypopen() does not return for the created child
 * process, but properly terminates the child process.
 *
 * \return Nothing
 */
void mypopentest05(void)
{
    ENTER();

    initresources();

    TRACE0("Trying mypopen(\"cat\", \"x\") ...\n");

    errno = 0;

    if (((fp[0] = mycheckedpopen("cat", "x")) != NULL) || (errno != EINVAL))
    {
        FAIL(MANDATORY);
    }

    freeresources();

    PASS();
}

/**
 * \brief Test 06
 *
 * Try to call mypopen() with a type parameters "rotz" and "what the ..."
 * (i.e., something that start with 'r' and 'w' but is actually a string
 * different from "r" and "w". - This should yield and error and errno
 * should be set to EINVAL.
 * Additionally verify that mypopen() does not return for the created child
 * process, but properly terminates the child process.
 *
 * \return Nothing
 */
void mypopentest06(void)
{
    ENTER();

    initresources();

    TRACE0("Trying mypopen(\"ls\", \"rotz\") ...\n");

    errno = 0;

    if (((fp[0] = mycheckedpopen("ls", "rotz")) != NULL) || (errno != EINVAL))
    {
        FAIL(MANDATORY);
    }

    TRACE0("Trying mypopen(\"cat\", \"what the ...\") ...\n");

    errno = 0;

    if (((fp[1] = mycheckedpopen("cat", "what the ....")) != NULL) || (errno != EINVAL))
    {
        FAIL(MANDATORY);
    }

    freeresources();

    PASS();
}

/**
 * \brief Test 07
 *
 * Call mypopen() with a command that requires input. Check if the created
 * child process is really there.
 * Additionally verify that mypopen() does not return for the created child
 * process, but properly terminates the child process.
 * Call mypclose() and check if the exit status of the child process has
 * been properly consumed via wait() or waitpid().
 *
 * \return Nothing
 */
void mypopentest07(void)
{
    char popencommand[] = POPENCOMMAND PIDPATTERN;
    char findprocesscommand[] = FINDPROCESSCOMMAND POPENCOMMAND PIDPATTERN;

    ENTER();

    (void) snprintf(
        popencommand,
        sizeof(popencommand),
        POPENCOMMAND,
        getpid()
        );

    (void) snprintf(
        findprocesscommand,
        sizeof(findprocesscommand),
        FINDPROCESSCOMMAND,
        popencommand
        );

    initresources();

    TRACE0("Trying mypopen(\"%s\", \"w\") ...\n", popencommand);

    if ((fp[0] = mypopen(popencommand, "w")) == NULL)
    {
        FAIL(MANDATORY);
    }

    TRACE0("Doing system(\"%s\") ...\n", findprocesscommand);


    blockonwrite(fp[0]);
    /* sleep(SLEEPTIME); */

    /* check if child is there and living - must be there */
    if (system(findprocesscommand) != 0)
    {
        FAIL(MANDATORY);
    }

    TRACE0("Doing mypclose(fp[0]) ...\n");

    if (mypclose(fp[0]) == -1)
    {
        FAIL(MANDATORY);
    }

    fp[0] = NULL;

    TRACE0("Doing system(\"%s\") ...\n", findprocesscommand);


    /*  sleep(SLEEPTIME); */

    /* check if child is there and living - must NOT be there*/
    if (system(findprocesscommand) == 0)
    {
        FAIL(MANDATORY);
    }

    freeresources();

    PASS();
}

/**
 * \brief Test 08
 *
 * Call mypopen(), fork(), mypclose() - forked child process must
 * still be there.
 * Additionally verify that mypopen() does not return for the created child
 * process, but properly terminates the child process.
 *
 * \return Nothing
 */
void mypopentest08(void)
{
    char popencommand[] = POPENCOMMAND PIDPATTERN;
    char findprocesscommand[] = FINDPROCESSCOMMAND POPENCOMMAND PIDPATTERN;

    ENTER();

    (void) snprintf(
        popencommand,
        sizeof(popencommand),
        POPENCOMMAND,
        getpid()
        );

    (void) snprintf(
        findprocesscommand,
        sizeof(findprocesscommand),
        FINDPROCESSCOMMAND,
        popencommand
        );

    initresources();

    TRACE0("Trying mypopen(\"%s\", \"w\") ...\n", popencommand);

    if ((fp[0] = mycheckedpopen(popencommand, "w")) == NULL)
    {
        FAIL(MANDATORY);
    }

    TRACE0("Creating dummy child ...\n");

    /* create dummy child */
    switch (dummychildpid = fork())
    {
    case -1:
        bailout("Cannot create child");
        break;

    case 0:
        exit(EXIT_SUCCESS); /* be a zombie */
        break;

    default:
        break;
    }

    TRACE0("Doing system(\"%s\") ...\n", findprocesscommand);

    blockonwrite(fp[0]);
    /*  sleep(SLEEPTIME); */

    /* check if child is there and living - must be there */
    if (system(findprocesscommand) != 0)
    {
        FAIL(MANDATORY);
    }

    TRACE0("Doing mypclose(fp[0]) ...\n");

    if (mypclose(fp[0]) == -1)
    {
        FAIL(MANDATORY);
    }

    fp[0] = NULL;

    TRACE0("Doing system(\"%s\") ...\n", findprocesscommand);

    /* sleep(SLEEPTIME); */

    /* check if child is there and living - must NOT be there*/
    if (system(findprocesscommand) == 0)
    {
        FAIL(MANDATORY);
    }

    TRACE0("Checking if dummy child is still there (as a zombie) ...\n");

    /* check if other child is still there (as a zombie) */
    if (kill(dummychildpid, 0) == -1)
    {
        FAIL(MANDATORY);
    }

    freeresources();

    PASS();
}

/**
 * \brief Test 09
 *
 * Call mypopen("echo 'This is a test.'; sleep 1; echo 'Second line
 * for test.'", "r"); read from file pointer; check if we read the two
 * lines; call mypclose()
 * Additionally verify that mypopen() does not return for the created child
 * process, but properly terminates the child process.
 *
 * \return Nothing
 */
void mypopentest09(void)
{
    char buffer[MAXLINE];

    static const char popen_cmd[] = "echo '" LINE1 "'; sleep 1; echo '" LINE2 "'";

    ENTER();

    initresources();

    TRACE0("Doing mypopen(\"%s\", \"r\") ...\n", popen_cmd);

    if (
        (fp[0] = mycheckedpopen(
            popen_cmd,
            "r"
            )
            ) == NULL
        )
    {
        FAIL(MANDATORY);
    }

    TRACE("Trying to read from pipe ...\n");

    if (fgets(buffer, sizeof(buffer), fp[0]) == NULL)
    {
        FAIL(MANDATORY);
    }

    TRACE("Comparing line read with expected result ...\n");

    if (strcmp(buffer, LINE1 "\n") != 0)
    {
        FAIL(MANDATORY);
    }

    TRACE("Trying to read from pipe ...\n");

    if (fgets(buffer, sizeof(buffer), fp[0]) == NULL)
    {
        FAIL(MANDATORY);
    }

    TRACE("Comparing line read with expected result ...\n");

    if (strcmp(buffer, LINE2 "\n") != 0)
    {
        FAIL(MANDATORY);
    }

    TRACE("Trying to read from pipe - should yield EOF ...\n");

    if ((fgets(buffer, sizeof(buffer), fp[0]) != NULL) || (!feof(fp[0])))
    {
        FAIL(MANDATORY);
    }

    TRACE0("Doing mypclose(fp[0]) ...\n");

    if (mypclose(fp[0]) == -1)
    {
        FAIL(MANDATORY);
    }

    fp[0] = NULL;

    freeresources();

    PASS();
}

/**
 * \brief Test 10
 *
 * Call mypopen("cat > some_temp_file", "w"); write to file pointer;
 * check if some_temp_file contains the respective text.
 * Additionally verify that mypopen() does not return for the created child
 * process, but properly terminates the child process.
 *
 * \return Nothing
 */
void mypopentest10(void)
{
    char buffer[MAXLINE];
    char tempfilename[] = "/tmp/popen.XXXXXXX";
    char popencommand[sizeof(tempfilename) + sizeof(POPENCOMMAND2)];
    int tempfile;

    ENTER();

    initresources();

    TRACE0("Getting name of tempfile ...\n");

    tempfile = mkstemp(tempfilename);
    if (tempfile == -1)
    {
        bailout("Cannot create temporary file");
    }

    (void) snprintf(
        popencommand,
        sizeof(popencommand),
        POPENCOMMAND2,
        tempfilename
        );

    TRACE0("Doing mypopen(\"%s\", \"w\") ...\n", popencommand);

    if ((fp[0] = mycheckedpopen(popencommand, "w")) == NULL)
    {
        FAIL(MANDATORY);
    }

    TRACE("Trying to write to pipe ...\n");

    if (fputs(LINE1 "\n", fp[0]) == EOF)
    {
        FAIL(MANDATORY);
    }

    TRACE("Trying to write to pipe ...\n");

    if (fputs(LINE2 "\n", fp[0]) == EOF)
    {
        FAIL(MANDATORY);
    }

    TRACE0("Doing mypclose(fp[0]) ...\n");

    if (mypclose(fp[0]) == -1)
    {
        FAIL(MANDATORY);
    }

    fp[0] = NULL;

    TRACE("Opening temporary file %s ...\n", tempfilename);

    if ((somefp = fopen(tempfilename, "r")) == NULL)
    {
        bailout("Cannot open temporary file for reading");
    }

    TRACE("Trying to read a line from file %s ...\n", tempfilename);

    if (fgets(buffer, sizeof(buffer), somefp) == NULL)
    {
        FAIL(MANDATORY);
    }

    TRACE("Comparing line read with expected result ...\n");

    if (strcmp(buffer, LINE1 "\n") != 0)
    {
        FAIL(MANDATORY);
    }

    TRACE("Trying to read a line from file %s ...\n", tempfilename);

    if (fgets(buffer, sizeof(buffer), somefp) == NULL)
    {
        FAIL(MANDATORY);
    }

    TRACE("Comparing line read with expected result ...\n");

    if (strcmp(buffer, LINE2 "\n") != 0)
    {
        FAIL(MANDATORY);
    }

    TRACE("Trying to read from pipe - should yield EOF ...\n");

    if ((fgets(buffer, sizeof(buffer), somefp) != NULL) || (!feof(somefp)))
    {
        FAIL(MANDATORY);
    }

    TRACE("Closing temporary file ...\n");

    fclose(somefp);
    somefp = NULL;

    TRACE("Removing temporary file ...\n");

    if (remove(tempfilename) == -1)
    {
        bailout("Cannot remove temporary file");
    }

    freeresources();

    PASS();
}

/**
 * \brief Test 11
 *
 * Set via setrlimit(2) the resource limit for open files
 * (RLIMIT_NOFILE) to 1; call mypopen() and check whether it fails (i.e,
 * return NULL with errno set to EMFILE) due to the failing pipe() call.
 * Additionally verify that mypopen() does not return for the created child
 * process, but properly terminates the child process.
 *
 * \return Nothing
 */
void mypopentest11(void)
{
    struct rlimit openfiles;
    rlim_t oldlimit;

    ENTER();

    initresources();

    TRACE("Getting resource limit on open files ...\n");

    if (getrlimit(RLIMIT_NOFILE, &openfiles) == -1)
    {
        bailout("Cannot obtain current resource limit on open files");
    }

    /* lower limit to 1 - ensure that next try to open a file fails */
    oldlimit = openfiles.rlim_cur;
    openfiles.rlim_cur = 1;

    TRACE0("Lowering resource limit on open files to 1 ...\n");

    if (setrlimit(RLIMIT_NOFILE, &openfiles) == -1)
    {
        bailout("Cannot set current resource limit on open files");
    }

    /* prepare to restore old limit */
    openfiles.rlim_cur = oldlimit;

    TRACE0("Trying mypopen(\"ls -al 2> /dev/null\", \"r\") ...\n");

    if ((fp[0] = mycheckedpopen("ls -al 2> /dev/null", "r")) != NULL)
    {
        TRACE0("Restoring old resource limit on open files ...\n");

        /* restore old limit */
        if (setrlimit(RLIMIT_NOFILE, &openfiles) == -1)
        {
            bailout("Cannot set current resource limit on open files");
        }

        FAIL(MANDATORY);
    }

    TRACE("Restoring old resource limit on open files ...\n");

    /* restore old limit */
    if (setrlimit(RLIMIT_NOFILE, &openfiles) == -1)
    {
        bailout("Cannot set current resource limit on open files");
    }

    freeresources();

    PASS();
}

/**
 * \brief Test 12
 *
 * Set via setrlimit(2) the resource limit for processes
 * (RLIMIT_NPROC); call mypopen() and check whether it fails with
 * errno set to EAGAIN (due to the failing fork() call).
 * Additionally verify that mypopen() does not return for the created child
 * process, but properly terminates the child process.
 * Furthermore verify that the pipe is properly closed in case fork() fails.
 * Last but not least call mypclose() and check that it fails as well in
 * order to test is the stored static PID for the child is properly initialized
 * to -1 (the value returned by a failed fork) and/or properly reset to -1
 * upon a failed fork().
 *
 * \return Nothing
 */
void mypopentest12(void)
{
    struct rlimit processes;
    rlim_t oldlimit;
    int blah = 0;

    ENTER();

    /* No initresources() here, since we only want stdin, stdout, stderr to be open */

    TRACE("Ensuring that only stdin, stdout, stderr are open ...\n");

    /* check that pipe has been properly removed => only stdin, stdout, stderr open */
    if (!VERIFY_CLOSED_NON_STD_FDS())
    {
	bailout("File descriptors other than stdin, stdout, stderr are open");
    }

    TRACE("Getting resource limit on processes ...\n");

    if (getrlimit(RLIMIT_NPROC, &processes) == -1)
    {
        bailout("Cannot obtain current resource limit on number of processes");
    }

    /* lower limit to 1 - ensure that next try to open a file fails */
    oldlimit = processes.rlim_cur;
    processes.rlim_cur = 1;

    TRACE0("Lowering resource limit on processes to 1 ...\n");

    if (setrlimit(RLIMIT_NPROC, &processes) == -1)
    {
        bailout("Cannot set current resource limit on number of processes");
    }

    /* prepare to restore old limit */
    processes.rlim_cur = oldlimit;

    TRACE0("Trying mypopen(\"ls -al 2> /dev/null\", \"r\") ...\n");

    if ((fp[0] = mycheckedpopen("ls -al 2> /dev/null", "r")) != NULL)
    {
        TRACE("Restoring old resource limit on processes ...\n");

        /* restore old limit */
        if (setrlimit(RLIMIT_NPROC, &processes) == -1)
        {
            bailout("Cannot set current resource limit on number of processes");
        }

        FAIL(MANDATORY);
    }

    TRACE("Restoring old resource limit on processes ...\n");

    /* restore old limit */
    if (setrlimit(RLIMIT_NPROC, &processes) == -1)
    {
        bailout("Cannot set current resource limit on number of processes");
    }

    TRACE("Verifying that only stdin, stdout, stderr are open ...\n");

    /* check that pipe has been properly removed => only stdin, stdout, stderr open */
    if (!VERIFY_CLOSED_NON_STD_FDS())
    {
	FAIL(MANDATORY);
    }

    TRACE("Verifying that mypclose() returns -1 since mypopen() did not succeed ...\n");

    /*
     * myclose() should signal an error here since mypopen() has not been
     * called successfully yet
     */
    if (((blah = mypclose(fp[0])) != -1) || (errno != ECHILD))
    {
        FAIL(MANDATORY);
    }

    /* No freeresources() here, since we did not call initresources() */

    PASS();
}

/**
 * \brief Test 13
 *
 * Check whether the exit status of the child process is extracted
 * properly with wait() or waitpid().
 * Additionally verify that mypopen() does not return for the created child
 * process, but properly terminates the child process.
 *
 * \return Nothing
 */
void mypopentest13(void)
{
    ENTER();

    initresources();

    TRACE0("Doing mypopen(\"exit %d\", \"r\") ...\n", EXPECTED_EXIT_STATUS);

    if ((fp[0] = mycheckedpopen("exit " EXPECTED_EXIT_STATUS_STRING, "r")) == NULL)
    {
        FAIL(MANDATORY);
    }

    TRACE0("Doing mypclose(fp[0]) ...\n");

    if (mypclose(fp[0]) != EXPECTED_EXIT_STATUS)
    {
        FAIL(MANDATORY);
    }

    fp[0] = NULL;

    freeresources();

    PASS();
}

/**
 * \brief Test 14
 *
 * Check for correct setting of errno to ECHILD in case the exit status
 * cannot be extracted (i.e., if WIFEXITED() returns FALSE).
 * Additionally verify that mypopen() does not return for the created child
 * process, but properly terminates the child process.
 *
 * \return Nothing
 */
void mypopentest14(void)
{
    int blah = 0;
    char command[MAX_COMMAND_LENGTH];
    const int verbose = getVerbose();

    ENTER();

    initresources();

    snprintf(
	command,
	sizeof(command),
	"killparent%s %lu",
	verbose == 0 ? " -v" : verbose == 1 ? " -vv" : verbose == 2 ? " -vvv" : "",
	(unsigned long) getpid()
	);

    TRACE0("Doing mypopen(\"%s\", \"w\") ...\n", command);

    if ((fp[0] = mycheckedpopen(command, "w")) == NULL)
    {
        FAIL(MANDATORY);
    }

    TRACE0("Doing mypclose(fp[0]) ...\n");

    errno = 0;

    if (((blah = mypclose(fp[0])) != -1) || (errno != ECHILD))
    {
        FAIL(MANDATORY);
    }

    fp[0] = NULL;

    freeresources();

    PASS();
}

/**
 * \brief Test 15
 *
 * Checks if the stored static PID for the child and the stored static
 * file pointer are properly properly reset in mypclose() and thus we
 * can do a sequence of mypopen(), mypclose(), mypopen(), mypclose()
 * correctly.
 * Additionally verify that mypopen() does not return for the created child
 * process, but properly terminates the child process.
 *
 * \return Nothing
 */
void mypopentest15(void)
{
    ENTER();

    initresources();

    TRACE0("Doing mypopen(\"ls -al 2> /dev/null\", \"r\") - Should succeed ...\n");

    if ((fp[0] = mycheckedpopen("ls -al 2> /dev/null", "r")) == NULL)
    {
        FAIL(MANDATORY);
    }

    TRACE0("Doing mypclose(fp[0]) - Should succeed ...\n");

    if (mypclose(fp[0]) == -1)
    {
        FAIL(MANDATORY);
    }

    TRACE0("Doing mypopen(\"ls -al 2> /dev/null\", \"r\") - Should succeed ...\n");

    if ((fp[0] = mycheckedpopen("ls -al 2> /dev/null", "r")) == NULL)
    {
        FAIL(MANDATORY);
    }

    TRACE0("Doing mypclose(fp[0]) - Should succeed ...\n");

    if (mypclose(fp[0]) == -1)
    {
        FAIL(MANDATORY);
    }

    fp[0] = NULL;

    freeresources();

    PASS();
}

/**
 * \brief Test 16
 *
 * Checks if the stored static PID for the child and the stored static
 * file pointer are properly properly reset in mypclose() and thus
 * when doing a sequence of mypopen(), mypclose() and mypclose(), the
 * second mypclose() fails and sets errno to ECHILD.
 * Additionally verify that mypopen() does not return for the created
 * child process, but properly terminates the child process.
 *
 * \return Nothing
 */
void mypopentest16(void)
{
    ENTER();

    initresources();

    TRACE0("Doing mypopen(\"ls -al 2> /dev/null\", \"r\") - Should succeed ...\n");

    if ((fp[0] = mycheckedpopen("ls -al 2> /dev/null", "r")) == NULL)
    {
        FAIL(MANDATORY);
    }

    TRACE0("Doing mypclose(fp[0]) - Should succeed ...\n");

    if (mypclose(fp[0]) == -1)
    {
        FAIL(MANDATORY);
    }

    TRACE0("Doing mypclose(fp[0]) - Should fail and set errno to ECHILD ...\n");

    if (mypclose(fp[0]) == -1)
    {
	if (errno != ECHILD)
	{
	    FAIL(MANDATORY);
	}
    }
    else
    {
	FAIL(MANDATORY);
    }

    fp[0] = NULL;

    freeresources();

    PASS();
}

/**
 * \brief Test 17
 *
 * Checks if the stored static PID for the child and the stored static
 * file pointer are properly properly reset (or remain set) to invalid values if
 * mypopen() fails somewhere in between (e.g., upon fdopen()). => Let
 * fdopen() fail by installing a malloc_hook(3) that returns NULL and
 * check if mypopen() can be called again ...).
 * Additionally verify that mypopen() does not return for the created child
 * process, but properly terminates the child process.
 *
 * \return Nothing
 */
void mypopentest17(void)
{
    ENTER();

    initresources();

    TRACE0("Doing mypopen(\"ls -al 2> /dev/null\", \"r\") - Should fail ...\n");

    let_malloc_fail = 1;

    if ((fp[0] = mycheckedpopen("ls -al 2> /dev/null", "r")) != NULL)
    {
	let_malloc_fail = 0;

        FAIL(MANDATORY);
    }

    TRACE0("Doing mypclose(fp[0]) - Should fail and set errno to ECHILD ...\n");

    if (mypclose(fp[0]) == -1)
    {
	if (errno != ECHILD)
	{
	    FAIL(MANDATORY);
	}
    }
    else
    {
	FAIL(MANDATORY);
    }

    let_malloc_fail = 0;

    TRACE0("Doing mypopen(\"ls -al 2> /dev/null\", \"r\") - Should now succeed ...\n");

    if ((fp[0] = mycheckedpopen("ls -al 2> /dev/null", "r")) == NULL)
    {
        FAIL(MANDATORY);
    }

    TRACE0("Doing mypclose(fp[0]) - Should succeed ...\n");

    if (mypclose(fp[0]) == -1)
    {
        FAIL(MANDATORY);
    }

    fp[0] = NULL;

    freeresources();

    PASS();
}

/**
 * \brief Test 18
 *
 * Call mypopen() with mode set to reading. Verify that stdin, stdout,
 * stderr, and the read end of the pipe are the only open file
 * descriptors after the mypopen() call.  Call mypclose(). Verify that
 * stdin, stdout, and stderr are the only open file descriptors after
 * the mypclose() call (i.e., verify that the read end of the pipe has
 * been properly closed).
 * Additionally verify that mypopen() does not return for the created child
 * process, but properly terminates the child process.
 *
 * \return Nothing
 */
void mypopentest18(void)
{
    int fds_allowed_open[] =
    {
	STDIN_FILENO,
	STDOUT_FILENO,
	STDERR_FILENO,
	0
    };

    ENTER();

    /* No initresources() here, since we only want stdin, stdout, stderr to be open */

    TRACE("Ensuring that only stdin, stdout, stderr are open ...\n");

    /* check that pipe has been properly removed => only stdin, stdout, stderr open */
    if (!VERIFY_CLOSED_NON_STD_FDS())
    {
	bailout("File descriptors other than stdin, stdout, stderr are open");
    }

    TRACE0("Doing mypopen(\"ls -al 2> /dev/null\", \"r\") ...\n");

    if ((fp[0] = mycheckedpopen("ls -al 2> /dev/null", "r")) == NULL)
    {
        FAIL(MANDATORY);
    }

    TRACE("Verifying that only read end of pipe, stdin, stdout, and stderr are open ...\n");

    /*
     * Verify that only fileno(fp[0]), stdin, stdout, stderr are open
     */
    fds_allowed_open[3] = fileno(fp[0]);
    if (!verify_closed_file_desc(fds_allowed_open, ARRAY_SIZE(fds_allowed_open)))
    {
	FAIL(MANDATORY);
    }

    TRACE0("Doing mypclose(fp[0]) ...\n");

    if (mypclose(fp[0]) == -1)
    {
        FAIL(MANDATORY);
    }

    fp[0] = NULL;

    TRACE("Verifying that only stdin, stdout, and stderr are open ...\n");

    /*
     * check that pipe has been properly removed and all other non-standard file
     * descriptors are closed again => only stdin, stdout, stderr open
     */
    if (!VERIFY_CLOSED_NON_STD_FDS())
    {
	FAIL(MANDATORY);
    }

    /* No freeresources() here, since we did not call initresources() */

    PASS();
}

/**
 * \brief Test 19
 *
 * Call mypopen() with mode set to reading. Verify that stdin, stdout,
 * stderr, are the only open file descriptors in the exec()'ed child process.
 * Call mypclose() and check that it succeeds.
 * Additionally verify that mypopen() does not return for the created child
 * process, but properly terminates the child process.
 *
 * \return Nothing
 */
void mypopentest19(void)
{
    char command[MAX_COMMAND_LENGTH];
    const int verbose = getVerbose();

    ENTER();

    snprintf(
	command,
	sizeof(command),
	"checkopenfds%s 0 1 2",
	verbose == 0 ? " -v" : verbose == 1 ? " -vv" : verbose == 2 ? " -vvv" : ""	
	);
    /* No initresources() here, since we only want stdin, stdout, stderr to be open */

    TRACE("Ensuring that only stdin, stdout, stderr are open ...\n");

    /* check that pipe has been properly removed => only stdin, stdout, stderr open */
    if (!VERIFY_CLOSED_NON_STD_FDS())
    {
	bailout("File descriptors other than stdin, stdout, stderr are open");
    }

    TRACE0("Doing mypopen(\"%s\", \"w\") ...\n", command);

    if ((fp[0] = mycheckedpopen(command, "w")) == NULL)
    {
        FAIL(MANDATORY);
    }

    TRACE0("Doing mypclose(fp[0]) ...\n");

    if (mypclose(fp[0]) != EXIT_SUCCESS)
    {
        FAIL(MANDATORY);
    }

    fp[0] = NULL;

    /* No freeresources() here, since we did not call initresources() */

    PASS();
}

/**
 * \brief Test 20
 *
 * Try to call mypclose() with a bogus file pointer (i.e., one that
 * has not been obtained via mypopen() but where the underlying file
 * descriptor is identical to the one of a file pointer obtained by
 * mypopen(). - This should yield an error and errno should be set to EINVAL.
 * Additionally verify that mypopen() does not return for the created child
 * process, but properly terminates the child process.
 *
 * \return Nothing
 */
void mypopentest20(void)
{
    FILE *fakereadfp;

    ENTER();

    initresources();

    TRACE0("Trying mypopen(\"cat\", \"w\") ...\n");

    if ((fp[0] = mycheckedpopen("cat", "w")) == NULL)
    {
        FAIL(MANDATORY);
    }

    TRACE0("Doing fdopen(fileno(fp)) ...\n");

    if ((fakereadfp = fdopen(fileno(fp[0]), "w")) == NULL)
    {
	bailout("Cannot create fake file pointer");
    }

    /*
     * take caution here, since this might hang if passed a bogus file
     * pointer (i.e., one not obtained via mypopen())
     */

    /*
     * store fp in global var, so that signal handler can close it upon
     * alarm
     */
    fptoclose = (volatile FILE **) &(fp[0]);

    (void) alarm(5);

    TRACE0("Trying mypclose(fakereadfp) ...\n");

    errno = 0;

    if ((mypclose(fakereadfp) != -1)  || (errno != EINVAL))
    {
        fakereadfp = NULL; /* myclose has closed this one */
        alarmoccurred = 0;

        FAIL(MANDATORY);
    }

    /*
     * cancel alarm
     */
    (void) alarm(0);

    TRACE0("Checking whether mypclose() timed out ...\n");

    if (alarmoccurred == 1)
    {
        alarmoccurred = 0;

        FAIL(MANDATORY);
    }

    freeresources();

    PASS();
}

/**
 * \brief Test 21
 *
 * Call mypopen() with mode set to writing. Verify that stdin, stdout,
 * stderr, and the read end of the pipe are the only open file
 * descriptors after the mypopen() call.  Call mypclose(). Verify that
 * stdin, stdout, and stderr are the only open file descriptors after
 * the mypclose() call (i.e., verify that the read end of the pipe has
 * been properly closed).
 * Additionally verify that mypopen() does not return for the created child
 * process, but properly terminates the child process.
 *
 * \return Nothing
 */
void mypopentest21(void)
{
    int fds_allowed_open[] =
    {
	STDIN_FILENO,
	STDOUT_FILENO,
	STDERR_FILENO,
	0
    };

    ENTER();

    /* No initresources() here, since we only want stdin, stdout, stderr to be open */

    TRACE("Ensuring that only stdin, stdout, stderr are open ...\n");

    /* check that pipe has been properly removed => only stdin, stdout, stderr open */
    if (!VERIFY_CLOSED_NON_STD_FDS())
    {
	bailout("File descriptors other than stdin, stdout, stderr are open");
    }

    TRACE0("Doing mypopen(\"grep foo 2> /dev/null\", \"w\") ...\n");

    if ((fp[0] = mycheckedpopen("grep foo 2> /dev/null", "w")) == NULL)
    {
        FAIL(MANDATORY);
    }

    TRACE("Verifying that only read end of pipe, stdin, stdout, and stderr are open ...\n");

    /*
     * Verify that only fileno(fp[0]), stdin, stdout, stderr are open
     */
    fds_allowed_open[3] = fileno(fp[0]);
    if (!verify_closed_file_desc(fds_allowed_open, ARRAY_SIZE(fds_allowed_open)))
    {
	FAIL(MANDATORY);
    }

    TRACE0("Doing mypclose(fp[0]) ...\n");

    if (mypclose(fp[0]) == -1)
    {
        FAIL(MANDATORY);
    }

    fp[0] = NULL;

    TRACE("Verifying that only stdin, stdout, and stderr are open ...\n");

    /*
     * check that pipe has been properly removed and all other non-standard file
     * descriptors are closed again => only stdin, stdout, stderr open
     */
    if (!VERIFY_CLOSED_NON_STD_FDS())
    {
	FAIL(MANDATORY);
    }

    /* No freeresources() here, since we did not call initresources() */

    PASS();
}

/**
 * \brief Test 22
 *
 * Check whether mypclose() behaves properly (i.e., returns -1 and
 * sets errno to ECHLD) if waitpid() fails for reasons different from
 * EINTR.  Additionally verify that mypopen() does not return for the
 * created child process, but properly terminates the child
 * process.
 *
 * \return Nothing
 */
void mypopentest22(void)
{
    struct sigaction ignore_sigchld;

    ENTER();

    initresources();

    /*
     * Ignore SIGCHLD => This will cause waitpid() to return -1 and set
     * errno to ECHLD
     */
    memset(&ignore_sigchld, 0, sizeof(ignore_sigchld));
    ignore_sigchld.sa_handler = SIG_IGN;
    ignore_sigchld.sa_flags = SA_NOCLDWAIT;

    TRACE0("Installing signal handler ignoring SIGCHLD ...\n");

    if (sigaction(SIGCHLD, &ignore_sigchld, 0) == -1)
    {
        bailout("Cannot install signal handler");
    }

    TRACE0("Doing mypopen(\"exit %d\", \"r\") ...\n", EXPECTED_EXIT_STATUS);

    if ((fp[0] = mycheckedpopen("exit " EXPECTED_EXIT_STATUS_STRING, "r")) == NULL)
    {
        FAIL(MANDATORY);
    }

    TRACE0("Doing mypclose(fp[0]) ...\n");

    errno = 0;

    /*
     * take caution here, since this might hang if waitpid() fails
     * and sets errno != EINTR
     */
    (void) alarm(5);

    if ((mypclose(fp[0]) != -1) || (errno != ECHILD))
    {
        FAIL(MANDATORY);
    }

    /*
     * cancel alarm
     */
    (void) alarm(0);

    fp[0] = NULL;

    freeresources();

    PASS();
}

static void failing_execl(int expected_exit_status)
{
    char command[REALLY_LONG_COMMAND_LENGTH];

    memset(command, 'x', sizeof(command));
    command[REALLY_LONG_COMMAND_LENGTH - 1] = '\0';

    TRACE0("Trying mypopen(\"%s\", \"r\") ...\n", command);

    if ((fp[0] = mycheckedpopen(command, "r")) == NULL)
    {
        FAIL(MANDATORY);
    }

    TRACE0("Doing mypclose(fp[0]) ...\n");

    if (mypclose(fp[0]) != expected_exit_status)
    {
        FAIL(MANDATORY);
    }

    fp[0] = NULL;
}

/**
 * \brief Test 23
 *
 * Do a mypopen() with a really long commandline that causes execl() to
 * fail and set errno to E2BIG. - Check whether mypopen() is successful
 * anyway (i.e., returns something != NULL) and check wehther the child
 * process correctly terminates with EXIT_FAILURE.
 * Additionally verify that mypopen() does not return for the created
 * child process, but properly terminates the child process.
 *
 * \return Nothing
 */
void mypopentest23(void)
{
    ENTER();

    initresources();

    failing_execl(EXIT_FAILURE);
	
    freeresources();

    PASS();
}

/**
 * \brief Test 24
 *
 * Checks if mypopen() properly handles the case where stdin already is the
 * read pipe end => closes stdin prior to calling mypopen().
 * Additionally verify that mypopen() does not return for the created child
 * process, but properly terminates the child process.
 *
 * \return Nothing
 */
void mypopentest24(void)
{  
    ENTER();
    
    char command[MAX_COMMAND_LENGTH];
    const int verbose = getVerbose();
    const int fds_open[] =
    {
        STDOUT_FILENO,
        STDERR_FILENO
    };

    snprintf(
	command,
	sizeof(command),
	"checkopenfds%s %d %d %d",
	verbose == 0 ? " -v" : verbose == 1 ? " -vv" : verbose == 2 ? " -vvv" : "",
	STDIN_FILENO,
        fds_open[0],
        fds_open[1]
	);

    /* No initresources() here, since we only want stdin, stdout, stderr to be open */

    TRACE0("Closing stdin ...\n");

    if (fclose(stdin) == EOF)
    {
	bailout("Cannot close stdin");
    }
    
    /* ensure that only stdout and stderr are open */
    if (!verify_closed_file_desc(fds_open, ARRAY_SIZE(fds_open)))
    {
	bailout("File descriptors other than stdout and stderr are open");
    }

    TRACE0("Doing mypopen(\"%s\", \"w\") ...\n", command);

    if ((fp[0] = mycheckedpopen(command, "w")) == NULL)
    {
        FAIL(MANDATORY);
    }

    TRACE0("Doing mypclose(fp[0]) ...\n");

    if (mypclose(fp[0]) != EXIT_SUCCESS)
    {
	FAIL(MANDATORY);
    }

    fp[0] = NULL;

    /* No freeresources() here, since we did not call initresources() */

    PASS();
}


/**
 * \brief Test 25
 *
 * Checks if mypopen() properly handles the case where stdout already is the
 * read pipe end => closes stdout prior to calling mypopen().
 * Additionally verify that mypopen() does not return for the created child
 * process, but properly terminates the child process.
 *
 * \return Nothing
 */
void mypopentest25(void)
{  
    ENTER();

    int saved_stdout_fileno;
    FILE *saved_stdout;
    
    char command[MAX_COMMAND_LENGTH];
    const int verbose = getVerbose();

    TRACE0("Saving stdout ...\n");

    /* save stdout */
    if ((saved_stdout_fileno = dup(STDOUT_FILENO)) == -1)
    {
	bailout("Cannot save STDOUT_FILENO via dup(STDOUT_FILENO)");
    }

    if ((saved_stdout = fdopen(saved_stdout_fileno, "w")) == NULL)
    {
	bailout("Cannot save stdout fdopen(saved_stdout_fileno)");
    }

    const int fds_open[] =
    {
        STDERR_FILENO,
	saved_stdout_fileno
    };

    snprintf(
	command,
	sizeof(command),
	"checkopenfds%s -t%d %d %d %d",
	verbose == 0 ? " -v" : verbose == 1 ? " -vv" : verbose == 2 ? " -vvv" : "",
	saved_stdout_fileno,
        STDOUT_FILENO,
	fds_open[0],
	fds_open[1]
	);

    /* For some weird reason, this is needed ... - Seems like the glibc does some magic here */
    TRACE0("Producing dummy output on saved_stdout ...\n");

    if (fprintf(saved_stdout, " \b") < 0)
    {
	bailout("Cannot print to saved_stdout");
    }

    if (fflush(saved_stdout) == EOF)
    {
	bailout("Cannot flush saved_stdout");
    }
    
    /* No initresources() here, since we only want stdin, stdout, stderr to be open */

    TRACE0("Closing stdin ...\n");

    if (fclose(stdin) == EOF)
    {
	bailout("Cannot close stdin");
    }

    TRACE0("Closing stdout ...\n");

    if (fclose(stdout) == EOF)
    {
	bailout("Cannot close stdout");
    }

    stdout = saved_stdout;
    setTraceStream(stdout);
    
    TRACE0("Restored stdout ...\n");
    
    /* ensure that only stdin, restored stdout, and stderr are open */
    if (!verify_closed_file_desc(fds_open, ARRAY_SIZE(fds_open)))
    {
	bailout("File descriptors other than stdin, restored stdout, and stderr are open");
    }

    TRACE0("Doing mypopen(\"%s\", \"r\") ...\n", command);
    
    if ((fp[0] = mycheckedpopen(command, "r")) == NULL)
    {
        FAIL(MANDATORY);
    }

    TRACE0("Doing mypclose(fp[0]) ...\n");

    if (mypclose(fp[0]) != EXIT_SUCCESS)
    {
	FAIL(MANDATORY);
    }

    fp[0] = NULL;

    /* No freeresources() here, since we did not call initresources() */

    PASS();
}


static void failing_dup2(int expected_exit_status)
{
    let_dup2_fail = 1;
    
    TRACE0("Doing mypopen(\"exit %d\", \"r\") ...\n", EXPECTED_EXIT_STATUS);

    if ((fp[0] = mycheckedpopen("exit " EXPECTED_EXIT_STATUS_STRING, "r")) == NULL)
    {
        FAIL(MANDATORY);
    }

    TRACE0("Doing mypclose(fp[0]) ...\n");

    if (mypclose(fp[0]) != expected_exit_status)
    {
        FAIL(MANDATORY);
    }

    let_dup2_fail = 1;

    fp[0] = NULL;
}

static void atexit_handler(void)
{
    ENTER();

    TRACE("Manipulating exit status to %d ...\n", OTHER_EXIT_STATUS);
    
    EXIT();

    _Exit(OTHER_EXIT_STATUS);
}

/**
 * \brief Test 26
 *
 * Do a mypopen() but let dup2() fail. - Check whether mypopen() is successful
 * anyway (i.e., returns something != NULL) and check whether the child
 * process correctly terminates with EXIT_FAILURE.
 * Additionally verify that mypopen() does not return for the created child
 * process, but properly terminates the child process.
 *
 * \return Nothing
 */
void mypopentest26(void)
{
    ENTER();

    initresources();

    failing_dup2(EXIT_FAILURE);
    
    freeresources();

    PASS();
}

/**
 * \brief Test 27
 *
 * Do a mypopen() but let dup2() fail. - Check whether mypopen() is successful
 * anyway (i.e., returns something != NULL) and check whether the child
 * process correctly terminates with EXIT_FAILURE.
 * Additionally ensure that no atexit() handlers are called in the child process
 * because of the child process calling exit() instead of _Exit() or _exit().
 * Additionally verify that mypopen() does not return for the created child
 * process, but properly terminates the child process.
 *
 * \return Nothing
 */
void mypopentest27(void)
{
    ENTER();

    initresources();

    TRACE0("Installing atexit() handler ...\n");

    if (atexit(atexit_handler) != 0)
    {
	bailout("Cannot install atexit() handler");
    }

    failing_dup2(EXIT_FAILURE);
    
    freeresources();

    PASS();
}

/**
 * \brief Test 28
 *
 * Do a mypopen() with a really long commandline that causes execl() to
 * fail and set errno to E2BIG. - Check whether mypopen() is successful
 * anyway (i.e., returns something != NULL) and check whether the child
 * process correctly terminates with EXIT_FAILURE.
 * Additionally ensure that no atexit() handlers are called in the child process
 * because of the child process calling exit() instead of _Exit() or _exit().
 * Additionally verify that mypopen() does not return for the created child
 * process, but properly terminates the child process.
 *
 * \return Nothing
 */
void mypopentest28(void)
{
    ENTER();

    initresources();

    TRACE0("Installing atexit() handler ...\n");

    if (atexit(atexit_handler) != 0)
    {
	bailout("Cannot install atexit() handler");
    }

    failing_execl(EXIT_FAILURE);
	
    freeresources();

    PASS();
}

static void do_simple_mypopen_mypclose_sequence(int number_of_eintrs)
{
    TRACE0("Preparing waitpid() to be interrupted by a signal for %d times ...\n", number_of_eintrs);
    number_of_interrupted_waitpids = number_of_eintrs;
    
    TRACE0("Doing mypopen(\"exit\", \"r\") ...\n");
    
    if ((fp[0] = mycheckedpopen("exit", "r")) == NULL)
    {
	FAIL(MANDATORY);
    }
    
    TRACE0("Doing mypclose(fp[0]) ...\n");
    
    if (mypclose(fp[0]) == -1)
    {
	FAIL(MANDATORY);
    }
    
    TRACE0("Preparing waitpid() to be interrupted by a signal for %d times ...\n", number_of_eintrs);
    number_of_interrupted_waitpids = number_of_eintrs;
    
    TRACE0("Doing mypopen(\"grep foo\", \"w\") ...\n");
    
    if ((fp[0] = mycheckedpopen("grep foo", "w")) == NULL)
    {
	FAIL(MANDATORY);
    }
    
    TRACE0("Doing mypclose(fp[0]) ...\n");
    
    if (mypclose(fp[0]) == -1)
    {
	FAIL(MANDATORY);
    }

    TRACE0("Preparing waitpid() to no longer be interrupted by a signal ...\n");
    number_of_interrupted_waitpids = 0;
}

/**
 * \brief Test 29
 *
 * Set errno to various values different from 0 to 1024 and do a
 * mypopen() - Check whether mypopen() is successful (should be). Do a
 * mypclose() and check whether that is successful (should be).
 *
 * \return Nothing
 */
void mypopentest29(void)
{
    ENTER();

    initresources();

    for (int i = 1; i < 1024; ++i)
    {
	TRACE0("Setting errno to %d ...\n", i);

	errno = i;

	do_simple_mypopen_mypclose_sequence(0);
    }

    fp[0] = NULL;
    
    freeresources();

    PASS();
}

/**
 * \brief Test 30
 *
 * Do a mypopen()/mypclose() session and simulate that the waitpid() call is
 * interrupted by a signal (returns -1 and sets errno to EINTR) a few times.
 * This should not cause mypclose() to fail.
 *
 * \return Nothing
 */
void mypopentest30(void)
{
    ENTER();

    initresources();

    do_simple_mypopen_mypclose_sequence(5);

    fp[0] = NULL;
    
    freeresources();

    PASS();
}

/**
 * \brief Test array
 *
 * This array holds all tests. Each entry contains a function pointer
 * to the test function, the name of the test, and a test description.
 *
 * \showinitializer
 */
static const struct test all_tests[] = {
#define X(func) { .testfunc = &func, .testfunc_name = #func, .testfunc_desc = MEMBERDEF_##func }
    X(mypopentest00),
    X(mypopentest01),
    X(mypopentest02),
    X(mypopentest03),
    X(mypopentest04),
    X(mypopentest05),
    X(mypopentest06),
    X(mypopentest07),
    X(mypopentest08),
    X(mypopentest09),
    X(mypopentest10),
    X(mypopentest11),
    X(mypopentest12),
    X(mypopentest13),
    X(mypopentest14),
    X(mypopentest15),
    X(mypopentest16),
    X(mypopentest17),
    X(mypopentest18),
    X(mypopentest19),
    X(mypopentest20),
    X(mypopentest21),
    X(mypopentest22),
    X(mypopentest23),
    X(mypopentest24),
    X(mypopentest25),
    X(mypopentest26),
    X(mypopentest27),
    X(mypopentest28),
    X(mypopentest29),
    X(mypopentest30),
#undef X
};


/**
 * \brief Main function
 *
 * This function is the main entry point of the program. - It calls
 * all test functions for mypopen()/mypclose() in sequence.
 *
 * \param argc number of arguments passed to the program
 * \param argv vector of arguments passed to the program.
 *
 * \return exit status of program
 * \retval EXIT_FAILURE Program terminated due to a failure.
 * \retval EXIT_SUCCESS Program terminated successfully.
 *
 */
int main(
    const int argc,
    char ** const argv
    )
{
    int c;
    const char *coloring = "auto";

    static const struct option long_opts[] = {
        { .name = "verbose",	.has_arg = no_argument,		.flag = NULL, .val = 'v' },
        { .name = "description",.has_arg = no_argument,		.flag = NULL, .val = 'd' },
        { .name = "color",	.has_arg = required_argument,	.flag = NULL, .val = 'c' },
        { .name = NULL,	},
    };
               
    while ((c = getopt_long(argc, argv, "vdc:", long_opts, NULL)) != EOF)
    {
        switch(c)
        {
        case 'v':
            setVerbose(getVerbose() + 1);
            break;

        case 'd':
            print_description = 1;
            break;

        case 'c':
            coloring = optarg;
            break;

        default:
            usage();
            break;
        }
    }

    if (strcmp(coloring, "auto") == 0) {
        if (!isatty(STDOUT_FILENO)) {
            emph_success = emph_failed = emph_off = "";
        }
    } else if (strcmp(coloring, "never") == 0) {
            emph_success = emph_failed = emph_off = "";
    } else if (strcmp(coloring, "always") == 0) {
    } else {
        usage();
        /* not reached */
    }

    ENTER();

    TRACE("Retrieving function pointer to libc's dup2() ...\n");

    if ((libc_dup2 = dlsym(RTLD_NEXT, "dup2")) == NULL)
    {
	bailout("Cannot retrieve function pointer to libc's dup2()\n");
    }

    TRACE2("libc's dup2() is located at 0x%lu ...\n", (unsigned long) libc_dup2);

    TRACE("Retrieving function pointer to libc's waitpid() ...\n");

    if ((libc_waitpid = dlsym(RTLD_NEXT, "waitpid")) == NULL)
    {
	bailout("Cannot retrieve function pointer to libc's waitpid()\n");
    }

    TRACE2("libc's waitpid() is located at 0x%lu ...\n", (unsigned long) libc_waitpid);

    TRACE("Installing signal handler for SIGALRM ...\n");

    (void) signal(SIGALRM, alarmhandler_terminate);

    /*
     * ignore SIGPIPE, since we have test where we let the child write to the pipe,
     * but we do a mypclose() immediately afterwards (and we are not interested in
     * the data written to the pipe) and we don't want the child to abnormaly exit
     * then
     */
    (void) signal(SIGPIPE, SIG_IGN);

    /* execute tests */
    if (argc == optind)
    {
        /* No parameters: do all as before */
        for (unsigned int i = 0; i < ARRAY_SIZE(all_tests); i++)
        {
            spawn(&all_tests[i]);
        }
    }
    else
    {
        /* Loop over the args */
        char **arg;
        for (arg = argv+optind; *arg != NULL; arg++)
        {
            char *endptr;
            const unsigned int num = strtoul(*arg, &endptr, 0);
            if (*endptr != '\0' || endptr == *arg)
            {
                errno = 0;
                bailout("Not a valid number: \"%s\"\n", *arg);
            }
            if (num >= ARRAY_SIZE(all_tests))
            {
                errno = 0;
                bailout("Invalid test number outside from [%d..%zu]\n", 0, ARRAY_SIZE(all_tests)-1);
            }
            
            spawn(&all_tests[num]);
        }
    }

    freeresources();

    exit(EXIT_SUCCESS);

    EXIT();
}

/*
 * =================================================================== eof ==
 */

/*
 * Local Variables:
 * c-basic-offset: 4
 * End:
 */
